<!-- npm install -g @angular/cli will give you the access to ng command in terminal.
When building a web application, you need to target multiple browsers and on top of that, you want to keep the JS bundle size
as small as possible. Doing it from scratch is hard, but you can use build command in production mode. It will automatically
minify and bundle your code and will also generate multiple bundles for differential loading. That means the browser will always
the smallest JS bundle possible, based on the features that are available on that specific browser.
The dist folder is the folder that we will deploy to a production hosting account or server.

By default angular generates an app component which essentially is the entry point into the app.

<app-root> element in index.html will be replaced by our actual angular JS application and the initial parsing of JS is called
bootstrapping.

In .ts file of each component, we define the internal state of that component and also ... .

In the beginning, we can leave the <router-outlet> element in app.component.html file.

With angular router, we can map components to URLs in the browser and the router can even help you do sth called code-splitting
with webpack to lazy load certain parts of your JS bundle.

Typescript decorators in case of angular allow us to pass an object that configures the way that the component
behaves. In that object, the selector prop is the name of that component as it will declared or used in the html.
Angular provides a special templating language that empowers your html with JS like logic. You can use conditional expressions,
loops and bind data directly to the html to writes templates that are expressive and also they're highly performant, when it comes
to reacting to data changes within the app and that's why declarative UI frameworks are popular. It makes it easy for devs to
keep your app data in sync with the actual UI and how it appears visually for end user.

In angular we can bind data to template by simply adding that data as a property to .ts file of component.
Under the hood angular is using change detection where it's looking for changes to props of component class and then updating the
UI in a highly performant way and all we have to do is to change the value of that prop. So when you set a property on the
component class, that's like setting it's internal state.
We can allow props to be input into a component by using @Input() and we can use ts to limit that prop to a certain values.
For example: @Input() value: 'x' | 'o' | 'a'; and we can input the values of @Input() from parent component of our component.

Learn: When there's nothing in a component that allows it to modify it's own state but instead, it all comes from the parent
 component of that component. So we generally call that component, a UI or a dumb component.
Dumb components are easy to test and they only concerns about the UI so there's not much to worry about in terms of bugs.
But in order to build a tic-tac-toe game, we need some kind of smart components to manage the state or data between the various
squares, which those squares are handled by square component.
So let's create a smart component which is board. Meaning it has internal state that can change.

The constructor() of component runs immidiately when that class is created but you don't generally do anything in the
constructor, a side from inject your dependencies.

Nabular and it's new feature named UI Bakery is a tool that allows you to visually create components and then download angular
codes. So run: ng add @nebular/theme it will automatically install and configure nabular in our project.
Now a few things changed. Now we have a themes.scss file which we can use to customize variables used in the
theme. Also if you go to app.module, you'll see a few ng modules are imported there.
ngModules are just mechanism that makes it possible to use angular in a progressive way. Or in other words, only use parts of
the framework that you ACTUALLY need. In our case, we must add nabular button module, because that's the only nabular component
that we wanna use, so we don't have to package the entire thing which would increase our bundle size and therefore decrease
performance. So let's import ngButtonModule and add it to imports array.
Also if you go to app.component.html, you'll see that we have a bunch of components that are prefixed by nb.
Now if you don't see them, just add the things that I wrote in that file. Now our UI looks a lot interesting.

Now by importing that nebular module into our app module, we have access to that button module and it's directives in our
components of app module. By using nbButton directive on our html elements, we can apply the nebular button theme and behaviors
to any html element.

For making this as a progressive web app that can be installed as a native app on desktop. In angular console,
click on add and you see different schematics available. Click on:
add @angular/pwa
When you run this command, it does several crucial things related to PWAs. The first thing it does, is to add JS code needed to
load a service worker in our angular app and it gives you a configuration file(ngsw-config.json), that you can use to
customize the behavior of the service worker. The worker is there primarly to make your app offline, so you can customize of
behavior of how those pages are cached and stored offline. Also it adds a manifest file and some icons for the actual install
button for the app, in assets/icons folder.

In order to determine if we have a valid progressive web app, we need to run our app in a production env. The first step
in that process is to run: ng build and that will compile all of our ts code, down to JS in the dist folder.

Now we need a place to deploy our code like firebase and we can add firebase to angular project by running:
ng add @angular/fire

Now we need to run: ng deploy . That's going to automatically deploy our PRODUCTION app to the firebase hosting account and that
would give you a hosting account when it's finished. Now you can run the project on the WEB. If you go to audits tab in chrome
devTools, we can analyze our app as a PWA and we have green check on every thing and what this means for the end user? It means
our app is installable on their device. -->
<nb-layout>
  <nb-layout-header fixed>
    <!-- Insert header here. -->
  </nb-layout-header>

  <nb-layout-column>
    <app-board></app-board>
    <router-outlet></router-outlet>
  </nb-layout-column>

  <nb-layout-footer fixed>
    <!-- Insert footer here. -->
  </nb-layout-footer>
</nb-layout>

